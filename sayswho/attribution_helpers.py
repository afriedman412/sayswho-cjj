from spacy.tokens.span import Span
from spacy.tokens import SpanGroup
from textacy.extract.triples import DQTriple
from collections import namedtuple
from typing import Union

LilMatch: tuple[int, Union[int, None], Union[int, None], bool] = namedtuple(
    "LilMatch", 
    ["quote_index", "cluster_index", "span_index", "contains_ent"], 
    defaults=(0, None, None, False)
)

ClusterEnt: tuple[int, int,Span, int] = namedtuple(
    "ClusterEnt",
    ["cluster_index", "span_index", "span", "ent_start"]
)

class Match:
    """
    Automatically loads info for a quoteAttributor quote/cluster match.

    For easier referencing and QC and auditing of actual match.

    TODO: test speaker against all clusters if no cluster

    Input:
        qa (quoteAttributor) - qa that generated the match
        quote_index (int) - index of qa quote
        cluster_index (str) - index of qa cluster
            (from autogenerated "coref_cluster_N", so its functionally an int, but its used as a string so no need to convert)
        cluster_member_index (int) - index of cluster member match
    """
    def __init__(self, qa, lil_match: LilMatch):
        self.quote = qa.quotes[lil_match.quote_index]
        self.content = self.quote.content.text
        self.quote_char = self.quote.content.start_char

        self.speaker = ' '.join([s.text for s in self.quote.speaker])
        self.speaker_index = self.quote.speaker[0].idx
        self.speaker_sent_char = self.quote.speaker[0].sent.start_char

        self.manual_speakers = None

        null_attrs = []

        self.cluster_index = lil_match.cluster_index
        self.cluster_ent = lil_match.contains_ent

        if lil_match.cluster_index:
            self.cluster = qa.clusters[lil_match.cluster_index]
            self.pred_speaker = sorted(list(set([c.text for c in self.cluster])), key=lambda c: len(c), reverse=True)[0]

        else:
            null_attrs += ['cluster', 'pred_speaker']

        if lil_match.cluster_index:
            self.span_match = self.cluster[lil_match.span_index]
            self.span_context = self.span_match.sent.text
            self.span_match_char = self.span_match.start_char
            self.span_match_sent_char = self.span_match.sent.start_char

        else:
            null_attrs += ['span_match', 'span_context', 'span_match_char', 'span_match_sent_char']
        
        for a in null_attrs:
            setattr(self, a, None)
        
        return
    
    def __repr__(self):
        return '\n'.join([f"{k}: {self.__dict__.get(k)}" for k in [
            "content", "speaker", "pred_speaker", "manual_speakers", "cluster_ent"
        ]])
    
    def compare_clusters(self, clusters):
        """
        If the match doesn't have a cluster, find any speakers in clusters that match manually.

        The idea here is if the speaker is "Rosenberg" to pull "Detective Jeff Rosenberg" from the clusters.

        quoteAttribution runs this automatically with its clusters if the match doesn't have a cluster!
        """
        self.manual_speakers = []
        for span in clusters.values():
            speaker_match = [v_ for v_ in span if self.speaker in v_.text.replace("@", "'")]
            if speaker_match:
                self.manual_speakers += speaker_match

        self.manual_speakers = list(set(self.manual_speakers))

def compare_spans(
            s1: Span, 
            s2: Span,
            min_entity_diff: int
            ) -> bool:
        """
        Compares two spans to see if their starts and ends are less than self.min_entity_diff.

        Input:
            s1 and s2 - spacy spans

        Output:
            bool - whether the two spans start and end close enough to each other to be "equivalent"

        """
        return all([
                abs(getattr(s1, attr)-getattr(s2,attr)) < min_entity_diff for attr in ['start', 'end']
            ])

def format_cluster(cluster, min_length: int):
    """
    Runs format_cluster_span on all spans, removes duplicates and sorts by reverse length.

    TODO: is there any reason to not remove duplicates here?

    Input:
        cluster - coref cluster

    Output:
        list of unique spans in the cluster
    """
    unique_spans = list(set([span for span in cluster]))
    sorted_spans = sorted(unique_spans, key=lambda s: len(s.text), reverse=True)
    return [s for s in sorted_spans if len(s.text) > min_length]

def compare_quote_to_cluster_member(
        quote: DQTriple,
        span: Span,
        min_speaker_diff: int
    ): 
    """
    Compares the starting character of the quote speaker and the cluster member, as well as the quote speaker sentence and the cluster member sentence to determine equivalence.
    
    Input:
        q (quote triple) - one textacy quote triple
        cluster_member - one spacy-parsed entity cluster member
        
    Output:
        bool
    """
    speaker = quote.speaker[0]
    if abs(speaker.sent.start_char - span.sent.start_char) < min_speaker_diff:
        if abs(speaker.idx - span.start_char) < min_speaker_diff:
            return True
    if span.start_char <= speaker.idx:
        if span.end_char >= (speaker.idx + len(speaker)):
            return True
    return False

def compare_quote_to_cluster(
        quote: DQTriple, 
        cluster: SpanGroup,
        min_speaker_diff: int
    ):
    """
    Finds first span in cluster that matches (according to self.compare_quote_to_cluster_member) with provided quote.
    
    TODO: Doesn't consider further matches. Is this a problem?

    Input:
        quote - textacy quote object
        cluster - coref cluster

    Output:
        cluster_index (int) or None - index of cluster member that matches quote (or None, if none match)
    """
    try:
        return next(
            cluster_index for cluster_index, cluster_member in enumerate(cluster) \
                if compare_quote_to_cluster_member(quote, cluster_member, min_speaker_diff)
        )
    except StopIteration:
        return -1